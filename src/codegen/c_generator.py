# -*- coding: utf-8 -*-
"""
Kapila C Code Generator
=======================

Generates C code from Kapila AST.

The generated code uses the Kapila runtime library (runtime/kapila.h).
"""

from typing import List, Dict
from ..parser.ast import (
    Node, Expr, Stmt, Program,
    NumberLit, StringLit, BoolLit, Word, QuotedWord,
    Block, ListLit, MapLit,
    BinaryExpr, UnaryExpr, Conditional, PostfixAction,
    WordDef, VarAssign, ExprStmt,
    NodeVisitor
)


class CGenerator(NodeVisitor):
    """Generates C code from Kapila AST."""

    def __init__(self):
        self.output: List[str] = []
        self.indent_level = 0
        self.word_defs: Dict[str, WordDef] = {}
        self.variables: Dict[str, str] = {}  # name -> C variable name
        self.var_counter = 0
        self.string_literals: List[str] = []

    def generate(self, program: Program) -> str:
        """Generate C code for a program."""
        # Collect word definitions first
        for stmt in program.statements:
            if isinstance(stmt, WordDef):
                self.word_defs[stmt.name] = stmt

        # Generate header
        self._emit_header()

        # Generate word functions
        for name, word_def in self.word_defs.items():
            self._generate_word_function(name, word_def)

        # Generate main
        self._emit("int main() {")
        self.indent_level += 1
        self._emit("kapila_init();")
        self._emit("")

        # Generate statements
        for stmt in program.statements:
            if not isinstance(stmt, WordDef):
                self.visit(stmt)

        self._emit("")
        self._emit("kapila_cleanup();")
        self._emit("return 0;")
        self.indent_level -= 1
        self._emit("}")

        return "\n".join(self.output)

    def _emit(self, line: str):
        """Emit a line of C code."""
        indent = "    " * self.indent_level
        self.output.append(indent + line)

    def _emit_header(self):
        """Emit C header - uses runtime library."""
        self._emit('/* Generated by Kapila Compiler */')
        self._emit('#include "kapila.h"')
        self._emit('')
        self._emit('/* === User-defined words === */')
        self._emit('')

    def _generate_word_function(self, name: str, word_def: WordDef):
        """Generate C function for a word definition."""
        c_name = self._mangle_name(name)
        self._emit(f'void {c_name}(void) {{')
        self.indent_level += 1

        for item in word_def.body:
            self.visit(item)

        self.indent_level -= 1
        self._emit('}')
        self._emit('')

    def _mangle_name(self, name: str) -> str:
        """Convert Kannada/special name to valid C identifier."""
        # Replace non-ASCII with hex codes
        result = []
        for ch in name:
            if ch.isalnum() or ch == '_':
                result.append(ch)
            else:
                result.append(f'_{ord(ch):x}_')
        return 'word_' + ''.join(result)

    # === Visitor Methods ===

    def visit_Program(self, node: Program):
        for stmt in node.statements:
            self.visit(stmt)

    def visit_ExprStmt(self, node: ExprStmt):
        self.visit(node.expr)

    def visit_VarAssign(self, node: VarAssign):
        self.visit(node.value)
        c_name = self._mangle_name(node.name)
        self.variables[node.name] = c_name
        self._emit(f'Value {c_name} = pop();')

    def visit_WordDef(self, node: WordDef):
        pass  # Handled separately

    def visit_NumberLit(self, node: NumberLit):
        if isinstance(node.value, int):
            self._emit(f'push_int({node.value});')
        else:
            self._emit(f'push_float({node.value});')

    def visit_StringLit(self, node: StringLit):
        escaped = node.value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')
        self._emit(f'push_str("{escaped}");')

    def visit_BoolLit(self, node: BoolLit):
        val = 'true' if node.value else 'false'
        self._emit(f'push_bool({val});')

    def visit_Word(self, node: Word):
        name = node.name

        # Check if it's a variable
        if name in self.variables:
            c_name = self.variables[name]
            self._emit(f'push_value({c_name});')
            return

        # Check if it's a user-defined word
        if name in self.word_defs:
            c_name = self._mangle_name(name)
            self._emit(f'{c_name}();')
            return

        # Built-in operations - map to runtime functions
        builtins = {
            # Arithmetic
            '+': 'add_op', '-': 'sub_op', '*': 'mul_op', '/': 'div_op', '%': 'mod_op',
            'ಕೂಡು': 'add_op', 'ಕೂಡಿಸು': 'add_op',
            'ಕಳೆ': 'sub_op',
            'ಗುಣಿಸು': 'mul_op',
            'ಭಾಗಿಸು': 'div_op',
            'ಶೇಷ': 'mod_op',
            # Comparison
            '<': 'lt_op', '>': 'gt_op', '=': 'eq_op',
            '!=': 'neq_op', '<=': 'lte_op', '>=': 'gte_op',
            'ಕಿರಿದು': 'lt_op', 'ಹಿರಿದು': 'gt_op', 'ಸಮ': 'eq_op',
            'ಸಮನಲ್ಲ': 'neq_op',
            # Logic
            'and': 'and_op', 'or': 'or_op', 'not': 'not_op',
            'ಮತ್ತು': 'and_op', 'ಅಥವಾ': 'or_op', 'ಅಲ್ಲ': 'not_op',
            # Stack manipulation
            'dup': 'dup_op', 'drop': 'drop_op', 'swap': 'swap_op',
            'over': 'over_op', 'rot': 'rot_op',
            'ನಕಲು': 'dup_op', 'ಬಿಡು': 'drop_op', 'ಅದಲುಬದಲು': 'swap_op',
            'ಮೇಲೆ': 'over_op', 'ತಿರುಗಿಸು': 'rot_op',
            # I/O
            'print': 'println_op', 'ಮುದ್ರಿಸು': 'println_op',
            # String operations
            'ಉದ್ದ': 'list_len_op',  # Works for both strings and lists
            'length': 'list_len_op',
            # List operations
            'ಮೊದಲ': 'list_first_op', 'first': 'list_first_op',
            'ಉಳಿದ': 'list_rest_op', 'rest': 'list_rest_op',
            'ತೆಗೆ': 'list_at_op', 'nth': 'list_at_op',
            'ಸೇರಿಸು': 'list_push_op', 'append': 'list_push_op',
            # File I/O
            'ಓದು': 'file_read_op', 'read-file': 'file_read_op',
            'ಬರೆ': 'file_write_op', 'write-file': 'file_write_op',
        }

        # Boolean literals
        bool_literals = {
            'true': True, 'false': False,
            'ನಿಜ': True, 'ಸುಳ್ಳು': False,
            'ಸರಿ': True, 'ತಪ್ಪು': False,
            'ಹೌದು': True, 'ಇಲ್ಲ': False,
            'ಬೇಸ': False,
        }

        if name in bool_literals:
            val = 'true' if bool_literals[name] else 'false'
            self._emit(f'push_bool({val});')
        elif name in builtins:
            op = builtins[name]
            self._emit(f'{op}();')
        else:
            self._emit(f'/* Unknown word: {name} */')

    def visit_BinaryExpr(self, node: BinaryExpr):
        self.visit(node.left)
        self.visit(node.right)

        ops = {
            '+': 'add_op', '-': 'sub_op', '*': 'mul_op', '/': 'div_op', '%': 'mod_op',
            '<': 'lt_op', '>': 'gt_op', '=': 'eq_op',
            '!=': 'neq_op', '<=': 'lte_op', '>=': 'gte_op',
            'ಮತ್ತು': 'and_op', 'and': 'and_op',
            'ಅಥವಾ': 'or_op', 'or': 'or_op',
        }

        if node.op in ops:
            self._emit(f'{ops[node.op]}();')

    def visit_UnaryExpr(self, node: UnaryExpr):
        self.visit(node.operand)
        if node.op == '-':
            self._emit('{ Value a = pop(); push_int(-a.i); }')
        elif node.op in ('not', 'ಅಲ್ಲ'):
            self._emit('not_op();')

    def visit_PostfixAction(self, node: PostfixAction):
        self.visit(node.value)
        for action in node.actions:
            self.visit(action)

    def visit_Conditional(self, node: Conditional):
        self.visit(node.condition)
        self._emit('if (pop().b) {')
        self.indent_level += 1
        self.visit(node.true_block)
        self.indent_level -= 1
        if node.false_block:
            self._emit('} else {')
            self.indent_level += 1
            self.visit(node.false_block)
            self.indent_level -= 1
        self._emit('}')

    def visit_Block(self, node: Block):
        for item in node.body:
            self.visit(item)

    def visit_ListLit(self, node: ListLit):
        """Generate code for list literal."""
        # Create a new list and push elements
        self._emit('{')
        self.indent_level += 1
        self._emit('KList* _list = list_new();')
        for elem in node.elements:
            self.visit(elem)
            self._emit('list_push_item(_list, pop());')
        self._emit('push_list(_list);')
        self.indent_level -= 1
        self._emit('}')

    def visit_MapLit(self, node: MapLit):
        self._emit('/* Map not yet supported in C codegen */')

    def visit_QuotedWord(self, node: QuotedWord):
        self._emit(f'push_str("{node.name}");')


def generate_c(program: Program) -> str:
    """Generate C code from a Kapila program."""
    generator = CGenerator()
    return generator.generate(program)
